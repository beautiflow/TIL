< 자바의 정석 p.411 ~ >.md

* iterator

iterate : (계산, 컴퓨터 처리 절차를) 반복한다. 
iterator : 반복자

=> 계산 같은 컴퓨터의 작업 처리 절차를 반복한다는 뜻 같다.

프로그래밍에서 반복기는 개발자가 컨테이너, 특히 리스트를 순회할 수 있게 해주는 객체다.
다양한 유형의 반복기는 조종 컨테이너의 인터페이스를 통해 제공된다. 주어진 반복기의 인터페이스와 의미는 고정되어 있지만, 반복기는 컨테이너 구현의 기본 구조로 구현되는 경우가 많으며 반복기의 작동 의미를 사용하기 위해 컨테이너와 밀접하게 연결되는 경우가 많다. 반복자는 순회를 수행하고 컨테이너의 데이터 요소에 대한 액세스를 제공하지만 자체적으로 반복을 수행하진 않는다.
반복기는 데이터베이스 커서와 작동이 유사하다.

* 반복자는 객체 지향적 프로그래밍에서 배열이나 그와 유사한 자료구조의 내부요소를 순회하는 객체다.

* iterator는 ArrayList, HashSet과 같은 컬렉션을 반복하는데 사용할 수 있는 객체다. iterator는 반복의 기술 용어기 때문에 반복자라고 한다.

자바에서 Iterator는 컬렉션 프레임워크에서 값을 가져오거나 삭제할 때 사용한다.
다음으로 컬렉션 프레임워크를 생성한 뒤

```java
Iterator<데이터타입> iterator명 = 컬렉션.iterator();
```

이렇게 사용하게 된다.

장점 :
Iterator는 모든 컬렉션 프레임워크에 공통으로 사용가능하다.
컬렉션 프레임워크에서 쉽게 값을 가져오고 제거할 수 있다.
3개의 메소드만 알면 되어서 사용하기 매우 쉽다.

단점 : 
처음부터 끝까지의 단방향 반복만 가능하다.
값을 변경하거나 추가가 불가능하다.
대량의 데이터를 제어할 때 속도가 느리가.

* 3개의 메소드
  1. Iterator.hasNext() : Iterator 안에 다음 값이 들어있는지 확인 / 들었으면 true, 안들었으면 false
  
  2. Iterator.next() : iterator의 다음 값 가져오기

  3. Iterator.remove() : iterator에서 next() 시에 가져왔던 값을 컬렉션(List, Set, Map)등에서 삭제, 반드시 next()후에 사용해야 함.

정리해보면

Iterator는 자바 컬렉션 프레임 워크에서 값을 가져오거나 삭제할 때 공통으로 사용 가능하며

Iterator<데이터타입> iterator명 = 컬렉션.iterator(); 이렇게 정의하고

while(iterator명.hasNext()){
    iterator.next();
}

이런 방식으로 주로 사용하게 된다. 




* 동기화 (Synchronization)
   : 작업들 사이의 수행 시기를 맞추는 것을 말한다. 
     자바에서 List, Set, Map과 같은 컬렉션의 구현 클래스를 사용할 때 바로 이 동기화가 중요한 이슈가 될 수 있는데, 동기화가 제공되는 것이 무조건적으로 좋은 것이 아니라 실행 속도 측면에서 성능의 차이가 있기 때문에 상황에 따라서 적절하게 사용하는 것이 좋다.


     * List Interface
        - ArrayList : 상대적으로 빠르고 요소에 대해 순차적으로 접근할 수 있다.
        - Vector : ArrayList의 이전 버전이며 모든 메서드가 동기화 되어 있다.
        - LinkedList : 순서가 변경되는 경우 노드 링크만 변경하면 되므로 삽입, 삭제가 빈번할 때 빠르다.
     
     * Set Interface
        - HashSet : 빠른 접근 속도를 가지고 있으나 순서를 예측할 수 없다.
        - LinkedHashSet : 요소가 추가된 순서대로 접근할 수 있다.
        - TreeSet : 요소들의 정렬 방법을 직접 지정할 수 있다.
     
     * Map Interface
       - HashMap : 중복을 허용하지 않고 순서를 보장하지 않으며 null값을 허용한다.
       - Hashtable : HashMap보다는 느리지만 동기화를 지원하며 null값을 허용하지 않는다.
       - TreeMap : 정렬된 순서대로 Key와 Value를 저장하므로 빠른 검색이 가능하지만 요소를 추가할 때 정렬로 인해 오래걸린다.
       - LinkedHashMap : HashMap과 기본적으로 동일하지만 입력한 순서대로 접근이 가능하다.


* Thread Safe 클래스
 - Vector 
 - Hashtable

* Thread UnSafe 클래스
 - HashSet
 - TreeSet
 - LinkedHashSet
 - ArrayList
 - LinkedList
 - HashMap
 - TreeMap
 - LinkedHashMap


* 제네릭
  : 직역하면 '일반적인'이라는 뜻 : 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법
  : 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미
  : 특정타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반 타입이라는 것

  만약에 우리가 어떤 자료구조를 만들어 배포하려고 한다. 그런데 String타입도 지원하고 싶고, Integer타입도 지원하고 싶고 많은 타입을 지원하고 싶다. 그러면 String에 대한 클래스, Integer에 대한 클래스 등 하나하나 타입에 따라 만들면 너무 비효율적이다. 이러한 문제를 해결하기 위해 제네릭이라는 것을 사용한다.

  - 장점 :
    1. 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.
    2. 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다. / 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌
    3. 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다. 




  