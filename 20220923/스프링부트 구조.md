* Client
  - 일반적으로 프론트엔드 모듈
  - 웹 브라우저에 띄워져 있는 화면 자체를 클라이언트라고 함

Controller, Service, DAO(Repository)까지 스프링부트 코드를 작성하는 부분

DB = 데이터 베이스

과정

client에서 controller로 요청이 들어온다. 일반적으로 데이터형식으로 DTO형식의 객체를 사용하게 된다.
예를 들어 회원가입을 하게되면 웹 브라우저에서 화면을 띄우고 회원가입을 하게된다.
간단한 회원가입으로 아이디, 이름, 패스워드, 이메일 정도만 정보를 받게된다. 그러면 이것을 DTO 객체에 담아서 컨트롤러로 회원가입 요청을 하게된다
그러면 Controller는 회원가입 요청인지 어떤 요청인지 판단한 후 그것과 맞게 되는 Service로 이 DTO객체를 같이 보내주게 된다.

그러면 이 Service 객체에 역할은 비즈니스 로직의 전반적인 내용을 처리하는 영역이다.
그렇기 때문에 회원가입에 필요한 내용들을 여기서 처리하게 되고 데이터베이스에 회원을 하나 추가하는 개념이기 때문에 회원가입을 할 때 받았던 4가지 말고도 그외의 내용들이 더 있다.
이런 내용들을 하나하나 더 채워넣는 자체를 서비스에서 한다.
예를 들면 가입일자, 멤버 등급, 회원가입에서 등급을 설정하고 회원가입을 하는게 아니기 때문에 서비스 객체에서 이것들을 처리해준다.

그래서 Service 객체에서 DTO에 들어가있는 데이터값을 활용해서 내용을 좀 더 붙이거나 빼거나 해서 Entity라는 객체를 만들게 된다.

Entity는 DB 테이블에 1:1로 매핑되는 데이터베이스와 가장 가까운 객체다.
이 Entity라는 객체를 만든 후 DAO라는 곳으로 보내게 된다.
DAO는 DB와 직접 통신하는 영역이다.
이 Entity의 값을 그대로 DB에 저장하거나 가져오거나 이런 작업을 수행하게 된다.
그렇기 때문에 Service부터 DAO, DB 쪽에서 사용하는 객체는 Entity라는 객체가 사용된다.

Client, Controller, Service 이 사이에서 왔다갔다하는 객체는 DTO를 사용한다.

밑에 있는 것들은 일반적으로 코드 설계를 할 때 Service와 DAO 같은 경우 클래스로 만들지 않고 interface로 만든다.
실체화된 실제 로직이 들어가있는 부분은 interface를 상속받은 implementation 클래스 객체가 비즈니스 로직을 갖게 된다.
이름은 보통 impl를 붙여 클래스를 만듦

@Entity
* Entity(Domain)
  - 데이터베이스에 쓰일 컬럼과 여러 엔티티 간의 연관관계를 정의
  - 데이터베이스의 테이블을 하나의 엔티티로 생각해도 무방함
  - 실제 데이터베이스의 테이블과 일대일로 매핑됨
  - 이 클래스의 필드는 각 테이블 내부의 칼럼을 의미

@DAO
* Repository
  - Entity에 의해 생성된 데이터베이스에 접근하는 메소드를 사용하기 위한 interface
  - Service와 DB를 연결하는 고리의 역할을 수행
  - DB에 적용하고자하는 CRUD를 정의하는 영역

@DAO
* DAO(Data Access Object)
  - 데이터베이스에 접근하는 객체를 의미(persistance layer)
  - Service가 DB에 연결할 수 있게 해줒는 역할
  - DB를 사용하여 데이터를 조회하거나 조작하는 기능을 전달

@DTO
* DTO(Data Transfer Object)
  - DTO는 VO(Value Object)로 불리기도 하며, 계층간 데이터 교환을 위한 객체를 의미한다.
  - VO의 경우 Read Only의 개념을 가지고 있음




