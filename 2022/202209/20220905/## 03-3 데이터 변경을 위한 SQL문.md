## 03-3 데이터 변경을 위한 SQL문

* 핵심포인트
  - INSERT 문은 테이블에 데이터를 입력하는 명령
  - AUTO_INCREMENT는 1부터 증가하는 값을 자동으로 입력해준다. 해당 열은 PRIMARY KEY로 지정해야 한다.
  - INSERT INTO ~ SELECT는 다른 테이블의 데이터를 가져와서 한 번에 대량으로 입력한다.
  - UPDATE는 기존에 입력되어 있는 값을 수정하며 주로 WHERE와 함께 사용된다.
  - DELETE는 행 단위로 삭제하며 WHERE가 없으면 전체 행이 삭제된다.

* 표로 정리하는 핵심 포인트

| 용어  | 약자  | 설명  |
|---|---|---|
| NULL  |   | 아무 것도 없는 값. AUTO_INCREMENT 열에 값을 입력할 때는 NULL로 지정함  |
| PRIMARY KEY  | PK  | 기본 키. AUTO_INCREMENT 열은 기본 키로 지정해야 함  |
| ALTER TABLE  |   | 테이블의 구조를 변형하는 SQL  |
| 시스템 변수  |   | MySQL에서 자체적으로 가지고 있는 설정값이 저장된 변수  |
| @@auto_increment_increment  |   | AUTO_INCREMENT의 증가값을 지정하는 시스템 변수  |
| DESCRIBE  | DESC  | 테이블의 구조를 확인하는 SQL  |
| TRUNCATE  |   | DELETE와 비슷한 기능이지만 전체 행을 삭제할 때 사용  |



## 04-1 MySQL의 데이터 형식

  * 핵심포인트
  - 정수형은 소수점이 없는 숫자이며, TINYINT, INT, BIGINT 등이 있다.
  - 문자형은 고정형 문자형인 CHAR와 가변형 문자형인 VARCHAR가 있다.
  - 실수형은 소수점 아래 7자리까지 표현되는 FLOAT와 소수점 아래 15자리까지 표현되는 DOUBLE이 있다.
  - 날짜형은 날짜를 저장하는 DATE, 시간을 저장하는 TIME, 날짜와 시간을 저장하는 DATETIME이 있다.
  - MySQL에서 제공되는 변수 앞에는 @를 붙인다.
  - 데이터 형식을 변경하는 형 변환 함수에는 CAST(), CONVERT()가 있다.

* 표로 정리하는 핵심 포인트

- 정수형

| 데이터 형식  | 바이트 수  | 숫자 범위  |
|---|---|---|
| TINYINT  | 1  | -128~127  |
| SAMLLINT  | 2  | -32.768~32.767  |
| INT  | 4  | 약 -21억~ + 21억  |
| BIGINT  | 8  | 약 -900경~900경  |

- 문자형

| 데이터 형식  | 바이트 수   |
|---|---|
| CHAR(개수)  | 1~255  |
| VARCHAR(개수)  | 1~16383  |


- 대량의 데이터 형식

| 데이터 형식  |   | 바이트 수 |
|---|---|---|
| TEXT 형식  | TEXT   | 1~65535  |
|   | LONG TEXT  | 1~4294967295 |
| BLOB 형식  | BLOB  | 1~65535 |
|   | LONGBLOB  | 1~4294967295 |

- 실수형

| 데이터 형식  | 바이트 수  | 설명  |
|---|---|---|
| FLOAT  | 4  | 소수점 아래 7자리까지 표현  |
| DOUBLE  | 8  | 소수점 아래 15자리까지 표현 |

- 날짜형

| 데이터 형식  | 바이트 수  | 설명  |
|---|---|---|
| DATE  | 3  | 날짜만 저장. YYYY-MM-DD 형식으로 사용  |
| TIME  | 3  | 시간만 저장. HH:MM:SS 형식으로 사용  |
| DATETIME  | 8  | 날짜 및 시간을 저장. YYYY-MM-DD HH:MM:SS 형식으로 사용  |

--

## 04-2  두 테이블을 묶는 조인

* 핵심 포인트
  - 일대다 관계란 한쪽 테이블에는 하나의 값만, 다른 쪽 테이블에는 여러 개의 값이 존재할 수 있는 관계를 말함.
  - 조인은 두 개의 테이블을 서로 묶어서 하나의 결과를 만들어 내는 것을 말함.
  - 내부 조인은 두 테이블을 조인할 때, 두 테이블에 모두 지정한 열의 데이터가 있어야 한다.
  - 외부 조인은 두 테이블을 조인할 때, 1개의 테이블에만 데이터가 있어도 결과가 나온다.
  - 상호 조인은 한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인 시키는 기능이다.
  - 자체 조인은 자신이 자신과 조인된다는 의미로, 1개의 테이블을 사용한다.

* 표로 정리하는 핵심 포인트

| 용어  | 설명  |
|---|---|
| 관계  | 두 테이블이 서로 연관되는 것  |
| 기본 키-외래 키 관계 | 두 테이블이 일대다 관계로 연결되기 위한 조건  |
| 별칭(alias)  | 조인에서 테이블의 이름을 짧게 표현하는 이름   |
| DISTINCT문  |  중복된 열의 값을 1개만 표현하는 구문  |
| LEFT OUTER JOIN  | 왼쪽 테이블의 모든 값이 출력되는 조인  |
| RIGHT OUTER JOIN  | 오른쪽 테이블의 모든 값이 출력되는 조인   |
| FULL OUTER HOIN  | 왼쪽 또는 오른쪽 테이블의 모든 값이 출력되는 조인  |
| CREATE TABLE ~ SELECT  | SELECT의 결과가 테이블로 생성되는 구문  |



## 04-3 SQL 프로그래밍

* 핵심 포인트
  - IF문은 조건식이며 참일 때 수행하는 IF, 참과 거짓일 때 각각 다른 부분이 수행되는 IF~ELSE가 있다.
  - 변수는 DECLEAR로 선언하고, SET값을 대입한다.
  - CASE문은 2가지 이상일 때 처리 가능하다. 그래서 CASE를 '다중분기'로도 부른다.
  - WHILE문은 조건식이 참인 동안에는 계속 반복한다. WHILE 문을 계속 실행하는 ITERATE와 WHILE문을 빠져나가는 LEAVE로 사용할 수 있다.
  - PREPARE는 SQL문을 실행하지 않고 미리 준비해놓고, EXECUTE는 준비한 SQL문을 실행한다. 이러한 방식을 동적 SQL이라 부른다.



## 05-1 테이블 만들기

* 핵심포인트
  - CREATE TABLE은 테이블을 생성하는 SQL로, 테이블 이름, 열 이름, 데이터 형식 등을 지정한다.
  - 열에 입력된 값이 1부터 자동 증가하도록 설정하려면 GUI에서는 AI를 체크하고, SQL에서는 AUTO_INCREMENT를 입력한다.
  - 열에 빈 값을 허용하지 않으려면 GUI에서는 NN을 체크하고, SQL에서는 NOT NULL을 입력한다.
  - 열을 기본 키로 지정하려면 GUI에서는 PK를 체크하고, SQL에서는 PRIMARY KEY를 입력한다.
  - 열을 외래 키로 지정하려면 FOREIGN KEY 예약어를 입력한다.

* 표로 정리하는 핵심 포인트

- 관련 중요 용어
  
| 용어  | 설명  |
|---|---|
| GUI  | Graphical User Interface의 약자로, 윈도에서 진행하는 작업을 의미  |   
| 로우(row)  | 테이블의 행. 레코드(record)라고도 부름  |   
| 컬럼(column)  | 테이블의 열. 필드(field)라고 부름   |   
| UNSIGNED  | 정수형 뒤에 붙이면 0부터 양의 정수만 입력됨  |   
| 백틱(`)  | 키보드 1 바로 왼쪽에 있는 키로, 테이블 이름이나 열 이름을 묶을 때 사용  |   
| NULL  | 열에 비어 있는 값을 허용할 때 설정함(별도로 지정하지 않으면 기본은 NULL)  |   
| 기본 키-외래 키  | 두 테이블이 일대다로 연결되는 관계  |   
| 주석(remark)  | 하이픈(-) 2개 이후에 한 칸을 띄고 설명을 써야 함  |   

- 회원 테이블의 설계
  
| 열 이름(한글)  | 열 이름(영문)  | 데이터 형식  | 기타  |
|---|---|---|---|
| 아이디  | mem_id  | CHAR(8)  | 기본 키(PK)  |
| 회원이름  | mem_name  | VARCHAR(10)  |   |
| 인원수  | men_numberr  | TINYINT  |   |
| 주소  | addr  | CHAR(2)  |   |
| 연락처 국번  | phone1  | CHAR(3)  |   |
| 전화번호  | phone2  | CHAR(8)   |   |
| 평균 키  | height  | TINYINT  | UNSIGNED  |
| 데뷔 일자  | debut_date  | DATE  |   |

- 구매 테이블의 설계
  
| 열 이름(한글)  | 열 이름(영문)  | 데이터 형식  | 기타  |
|---|---|---|---|
| 순번  | num  | INT  | 기본 키(PK). 자동 증가  |
| 아이디  | mem_id  | CHAR(8)  | 외래 키(FK)  |
| 제품 이름  | prod_name  | CHAR(6)  |   |
| 분류  | group_name  | CHAR(4)  |   |
| 가격  | price  | INT  | UNSIGNED  |
| 수량  | amount  | SMALLINT  | UNSIGNED  |



## 05-2  제약 조건으로 테이블을 견고하게

* 핵심 포인트
  - 기본 키는 행 데이터 중에서 데이터를 구분할 수 있는 식별자 역할을 합니다.
  - 외래 키는 두 테이블의 관계를 연결해준다. 외래 키가 설정된 열은 꼭 다른 테이블의 기본 키와 연결된다.
  - 고유 키는 중복되지 않는 유일한 값이다. 기본 키와 차이점은 NULL 값을 허용한다.
  - 체크는 입력되는 데이터를 점검하는 기능이다.
  - 기본값은 값을 입력하지 않았을 때 자동으로 입력될 값을 미리 지정한다.
  - 널(Null)값을 혀용하려면 생략하거나 NULL을 사용하고, 허용하지 않으려면 NOT NULL을 사용한다.

* 표로 정리하는 핵심 포인트

| 용어  | 설명  |
|---|---|
| 제약조건  | 데이터의 무결성을 지키기 위한 제한된 조건  |
| ALTER TABLE  | 이미 만들어진 테이블을 수정하는 SQL문  |
| ADD CONSTRAINT  | 제약조건을 추가하는 SQL문  |
| 기준 테이블  | 기본 키-외래 키 관계가 맺어진 테이블 중 기본 키가 설정된 테이블   |
| 참조 테이블  | 기본 키-외래 키 관계가 맺어진 테이블 중 외래 키가 설정된 테이블  |
| ON UPDATE CASCADE  | 기준 테이블의 기본 키를 변경하면 참조 테이블의 외래 키도 변경되는 기능  |
| ON DELETE CASCADE  | 기준 테이블의 기본 키를 삭제하면 참조 테이블의 외래 키도 삭제되는 기능  |



## 05-3 가상의 테이블 : 뷰

* 핵심 포인트
  - 모든 데이터베이스 개체는 테이블과 관련이 있지만, 특히 뷰는 테이블에 직접 접근하므로 밀접하게 연관된다.
  - 뷰를 한마디로 표현하면 '가상의 테이블'이라고 할 수 있다. 뷰의 실체는 SELECT문으로 구성되어 있다.
  - 하나의 테이블과 관련되면 단순 뷰, 2개 이상의 테이블과 관련되면 복합 뷰라고 부른다. 복합 뷰로는 테이블의 데이터를 수정할 수 없다.
  - 뷰는 특정 사용자가 테이블에 접근하지 못하도록 하고, 필요한 부분에만 접근하도록 함으로써 보안에 도움이 된다.

* 표로 정리하는 핵심 포인트
  
| 용어  | 설명  |
|---|---|
| CREATE VIEW  | 뷰를 생성하는 SQL  |
| 별칭  | 뷰에서 사용될 열의 이름을 별칭을 사용해서 테이블과 다르게 지정할 수도 있음  |
| 백틱  | 뷰를 조회할 때 열 이름에 공백이 있으면 붙여주는 기호  |
| ALTER VIEW  | 뷰를 수정하는 SQL  |
| DROP VIEW  | 뷰를 삭제하는 SQL  |
| CREATE OR REPLACE VIEW  | 기존에 뷰가 있으면 덮어쓰고, 없으면 새로 생성하는 SQL  |
| DESCRIBE  | 뷰 또는 테이블의 정보를 조회하는 SQL  |
| SHOW CREATE VIEW | 뷰의 소스코드를 보여주는 SQL  |
| WITH CHECK OPTION  | 뷰에 설정된 조건만 입력되도록 지정하는 SQL  |
| CHECK TABLE  | 뷰 또는 테이블의 상태를 확인하는 SQL  |



## 06-1 인덱스 개념을 파악하자

* 핵심 포인트
- 클러스터형 인덱스는 영어사전처럼 내용이 이미 정렬되어 있는 인덱스이다. 기본 키로 지정하면 클러스터형 인덱스가 생성되고 해당 열로 자동 정렬된다.
- 보조 인덱스는 일반 책의 찾아보기와 같이 별도의 공간에 인덱스가 생성된다. 고유 키로 지정하면 보조 인덱스가 생성되고 자동 정렬되지 않는다.
- 고유 인덱스는 값이 중복되지 않는 인덱스이다. 기본 키나 고유 키로 지정하면 값이 중복되지 않아서 고유 인덱스가 자동 생성된다.

* 표로 정리하는 핵심 포인트

- 클러스터형 인덱스와 보조 인덱스 비교

|   | 클러스터형 인덱스  | 보조 인덱스   |
|---|---|---|
| 영문  | Clustered Index  | Secondary Index  |
| 관련 제약 조건  | 기본 키(Primary Key)  | 고유 키(Unique)   |
| 테이블당 개수  | 1개  | 여러 개  |
| 정렬  | 지정한 열로 정렬됨  | 정렬되지 않음  |
| 비유  | 영어사전  | 일반 책의 찾아보기  |



## 06-2 인덱스의 내부 작동

* 핵심 포인트
  - 인덱스는 내부적으로 균형트리, 즉 나무를 거꾸로 표현한 자료 구조로 구성된다.
  - 노드는 트리 구조에서 데이터가 저장되는 공간을 말하는데, MySQL에서는 노드를 페이지라고 부른다.
  - 전체 테이블 검색은 데이터를 처음부터 끝까지 검색하는 것이다. 인덱스가 없으면 전체 페이지를 검색하는 방법밖에 없다.
  - 페이지 분할은 데이터를 입력할 떄, 입력할 페이지에 공간이 없어서 2개 페이지로 데이터가 나눠지는 것을 말한더.
  - 인덱스 검색은 클러스터형 또는 보조 인덱스를 이용해서 데이터를 검색하는 것이다. 속도는 인덱스를 사용하지 않았을 때보다 더 빠르다.



## 06-3 인덱스의 실제 사용

* 핵심 포인트
  - CREATE INDEX 문으로 인덱스를 직접 생성한다.
  - 기본 키 및 고유 키로 자동 생성된 인덱스는 ALTER TABLE로 제거하고, CREATE INDEX 문으로 생성한 인덱스는 DROP INDEX문으로 제거한다.
  - 단순 보조 인덱스는 중복을 허용하는 보조 인덱스이며, CREATE INDEX 문을 사용한다.
  - 고유 보조 인덱스는 중복을 허용하지 않는 보조 인덱스이며, CREATE UNIQUE INDEX문을 사용한다.
  - MySQL 워크벤치에서 SQL을 실행한 후, 실행 계획에서 인덱스의 사용 여부를 확인할 수 있다.



## 07-1 스토어드 프로시저 사용 방법

* 핵심 포인트
  - 스토어드 프로시저는 MySQL에서 제공되는 프로그래밍 기능이다.
  - 스토어드 프로시저는 BEGIN~END 사이에 코드를 구현한다.
  - 스토어드 프로시저를 작성한 후, CALL 문을 통해서 스토어드 프로시저를 호출한다.
  - 입력 매개변수는 스토어드 프로시저에 값을 전달한다. 형식은 IN을 앞에 붙인다.
  - 출력 매개변수는 스토어드 프로시저에서 계산된 결과를 돌려 받는다. 형식은 OUT을 앞에 븉인다.
  - 동적 SQL은 다이나믹하게 SQL을 생성한 후 실행한다. PREPARE문과 EXECUTE 문을 사용한다.



## 07-2 스토어드 함수와 커서

* 핵심 포인트
- MySQL은 다양한 내장 함수로 제공되지 않는 기능을 스토어드 함수로 만들어서 사용할 수 있다.
- 스토어드 함수는 RETURNS 예약어를 통해서 반환될 데이터의 형식을 미리 지정해 놓아야 한다.
- 스토어드 함수의 매개변수는 모두 다 스토어드 함수로 값이 들어오는 입력 매개변수이다. 스토어드 프로시저와 달리 출력 매개변수는 없다.
- 커서는 한 행씩 처리되도록 하는 기능이다. DECLEAR로 선언할 수 있으며, 그 내용은 SELECT문 이다.
- 커서는 행이 끝날 때까지 계속 반복한다. 행의 끝을 판단하기 위해 변수 endOfRow를 준비하고 TRUE값인지 체크하는 방식을 사용한다.



## 07-3 자동 실행되는 트리거
* 핵심 포인트
  - 트리거는 테이블에서 DML문(INSERT, UPDATE, DELETE등)의 이벤트가 발생할 때 작동한다.
  - AFTER DELETE는 DELETE문이 발생된 후에 트리거를 작동하라는 의미이다.
  - 트리거는 행 데이터가 삭제 또는 수정되면 기존 데이터를 백업 테이브렝 저장하도록 할 수 있다.
  - 트리거에서 기존 데이터는 OLD 테이블에, 새로운 데이터는 NEW 테이블에 잠깐 저장된다. OLD 및 NEW 테이블은 MySQL이 내부적으로 관리한다.
